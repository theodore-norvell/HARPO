type Ref;
type Field x;
type HeapType = <x> [Ref,Field x]x;
var Heap:HeapType;
var LockPermission : PermissionType where (forall <x> r: Ref, f: Field x :: LockPermission[r,f] == 0.0);

type ArrayRef x;
type ArrayHeapType = <x> [ArrayRef x, int]x;
var ArrayHeap:ArrayHeapType;

type Perm = real;
type PermissionType = <x> [Ref,Field x]Perm;
type ArrayPermissionType = <x>[ArrayRef x, int] Perm;
var ArrayLockPermission : ArrayPermissionType where (forall <x> r: ArrayRef x, f: int :: ArrayLockPermission[r,f] == 0.0);
function Length<x>(Field (ArrayRef x))returns(int);

const unique minInt8:int;
axiom minInt8 == -128;
const unique maxInt8:int;
axiom maxInt8==127;

const unique minInt16:int;
axiom minInt16 == -32768;
const unique maxInt16:int;
axiom maxInt16 == 32767;

const unique minInt32:int;
axiom minInt32 == -2147483648;
const unique maxInt32:int;
axiom maxInt32 == 2147483647;

const unique minInt64:int;
axiom minInt64 == -9223372036854775808;
const unique maxInt64:int;
axiom maxInt64== 9223372036854775807;

function isInt8(int) returns (bool);
axiom (forall x:int :: isInt8(x) <==> minInt8 <= x && x <= maxInt8);

function isInt16(int) returns (bool);
axiom (forall x:int :: isInt16(x) <==> minInt16 <= x && x <= maxInt16);

function isInt32(int) returns (bool);
axiom (forall x:int :: isInt32(x) <==> minInt32 <= x && x <= maxInt32);

function isInt64(int) returns (bool);
axiom (forall x:int :: isInt64(x) <==> minInt64 <= x && x <= maxInt64);

const unique TenPow16 : real;
axiom TenPow16 == 10000000000000000.0; // 10 ^ 16
const unique TenPow32 : real;
axiom TenPow32 == 100000000000000000000000000000000.0; // 10 ^ 32
const unique TenPow64 : real;
axiom TenPow64 == 10000000000000000000000000000000000000000000000000000000000000000.0; // 10 ^ 64

const unique minReal16:real;
axiom minReal16 == -6.10/10000.0; // 6.10 E - 5 
const unique maxReal16:real;
axiom maxReal16 == 6.55*10000.0; // 6.55 E + 4

const unique minReal32:real;
axiom minReal32 == -3.402823466 / (TenPow32*10000.0) ; // 3.402823466 E - 38 
const unique maxReal32:real;
axiom maxReal32 == 3.402823465 * (TenPow32*10000.0) ;  //3.402823465 E + 38

const unique minReal64:real;
axiom minReal64 == -1.7976931348623157 / (TenPow64*TenPow64*TenPow64*TenPow64*TenPow32*TenPow16*1000.0); // -1.7976931348623157 E - 308 
const unique maxReal64:real;
axiom maxReal64 == 1.7976931348623156 * (TenPow64*TenPow64*TenPow64*TenPow64*TenPow32*TenPow16*1000.0); // 1.7976931348623156 E + 308

function isReal16(real) returns (bool);
axiom (forall x:real :: isReal16(x) <==> minReal16 <= x && x <= maxReal16);

function isReal32(real) returns (bool);
axiom (forall x:real :: isReal32(x) <==> minReal32 <= x && x <= maxReal32);

function isReal64(real) returns (bool);
axiom (forall x:real :: isReal64(x) <==> minReal64 <= x && x <= maxReal64);

function isBool(bool) returns (bool);
axiom (forall x: bool :: isBool(x) <==> x == true || x == false);

const unique minPer : Perm;
axiom minPer == 0.0;
const unique maxPer : Perm;
axiom maxPer == 1.0;

function isValidPermission(Perm) returns (bool);
axiom (forall x: Perm:: isValidPermission(x) <==> minPer <= x && x <= maxPer);

type ClassName;
function dtype(Ref) returns (ClassName);


// Prelude ends